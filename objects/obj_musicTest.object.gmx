<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Initialise variables
str_track = "";
int_current = 0;
int_sound = -1;
int_audio = -1;
int_trackPos = -1;
int_closestEnd = -1;
int_movEnd = 10000;
bool_recalculateMov = false;
bool_needsToJump = false;
int_nextTrack = 0;
int_nextMov = -1;

// Load json with data regarding music tracks
str_json = scr_getFile("musicTest.json");
map_json = json_decode(str_json);
list_tracks = map_json[? "tracks"];

// Load info for first track (track zero)
scr_loadTrack(int_nextTrack);

// Set information text for drawing
str_info = "Use left and right keys to signal which tracks to switch to.#Use up and down keys to move along track position faster.#Use space to pause the music.#Use enter to change track timing while paused.#Use R to restart.#";
if (os_browser != browser_chrome) {
    str_info += "Please use Chrome, otherwise it doesnt work."
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Game restart and end
if (keyboard_check(ord('R'))) {
    audio_stop_all();
    game_restart();
}
if (keyboard_check(vk_escape)) {
    game_end();
}

// Change current track from 0 (mute) to 1 (one) to 2 (two)
bool_switchTracks = false;
if ((keyboard_check_pressed(vk_left)) &amp;&amp; (int_current &gt; 0)) {
    int_current -= 1;
    if (int_current == 0) {
        audio_stop_all();
        game_restart();
    }
    else {
        bool_switchTracks = true;
    }
}
if ((keyboard_check_pressed(vk_right)) &amp;&amp; (int_current &lt; 2)) {
    int_current += 1;
    if (!audio_is_playing(int_sound)) {
        int_audio = audio_play_sound(int_sound,1,1);
    }
    else {
        bool_switchTracks = true;
    }
}

// Get ready to switch the tracks or (if they are switching back) cancel the jump
if (bool_switchTracks == true) {
    if (int_currentTrack != (int_current -1)) {
        bool_needsToJump = true;
        int_nextTrack = int_current-1;
        int_nextMov = -1;
    }
    else {
        bool_needsToJump = false;
    }
}

// Code after this point must have sound playing
if (!audio_is_playing(int_sound)) {
    exit;
}

// Pause/Unpause track
if (keyboard_check_pressed(vk_space)) {
    if (audio_is_paused(int_audio)) {
        audio_resume_sound(int_audio);
    }
    else {
        audio_pause_sound(int_audio);
    }
}

// Get initial track position
int_trackPos = audio_sound_get_track_position(int_audio);

// Set track position to zero if a jump to a new track has just occured
if (bool_recalculateMov == true) {
    int_trackPos = int_nextPos;
    audio_sound_set_track_position(int_audio,int_trackPos);
}

// Reset the recalculation variable since we've just recalculated everything
bool_recalculateMov = false;
    
// Change track position
if (keyboard_check_pressed(vk_enter)) {
    //audio_pause_sound(int_audio);
    int_trackJump = get_integer("Jump to second?",int_trackPos);
    //audio_resume_sound(int_audio);
    audio_sound_set_track_position(int_audio, int_trackJump - int_trackPos);
    int_trackPos = audio_sound_get_track_position(int_audio);
    bool_recalculateMov = true;
}

// Move along track position with keyboard
if (keyboard_check(vk_up)) {
    audio_sound_set_track_position(int_audio, int_trackPos + 0.5);
    int_trackPos = audio_sound_get_track_position(int_audio);
    bool_recalculateMov = true;
}
if (keyboard_check(vk_down)) {
    audio_sound_set_track_position(int_audio, int_trackPos - 0.5);
    int_trackPos = audio_sound_get_track_position(int_audio);
    bool_recalculateMov = true;
}

// Main code for calculating movements and deciding on movement / track jumps

if (int_trackPos &gt;= int_movEnd) {
    if (bool_needsToJump == true) {
        scr_loadTrack(int_nextTrack);
    }
    else {
        // Once we reach the end of the movement, we go to the start of the loop
        scr_loadMovementByType("loop");
    }
    bool_recalculateMov = true;
    
}

if ((int_trackPos &gt;= int_closestEnd) || (bool_recalculateMov == true)) {
    // If a jump is pending, do it at this exit point (but not if jump just occured)
    if ((bool_needsToJump == true) &amp;&amp; (bool_recalculateMov == false)) {
        scr_loadTrack(int_nextTrack);
    }
    else {
        // No position changing needed after this movement (carry on as usual)
        int_nextPos = int_trackPos;
    }
    
    // Recalculate which is the current movement
    for(i = 0; i &lt; int_movements; i++) {
        map_movement = list_movements[| i];
        int_movStart = map_movement[? "timeStart"];
        int_movEnd = map_movement[? "timeEnd"];
        if ((int_trackPos &gt;= int_movStart) &amp;&amp; (int_trackPos &lt; int_movEnd)) {
            break;
        }
    }
    
    // Also recalculate the closest endpoint in the current movement
    list_endpoints = map_movement[? "endpoints"];
    int_endpoints = ds_list_size(list_endpoints);
    int_closestEnd = audio_sound_length(int_audio);
    for (i = 0; i &lt; int_endpoints; i++) {
        map_endpoint = list_endpoints[| i];
        int_timestamp = map_endpoint[? "timestamp"]
        if (int_trackPos &lt; int_timestamp) {
            if (int_closestEnd &gt; int_timestamp) {
                int_closestEnd = int_timestamp;
            }
        }
    }
    
    // No need to recalculate movement if no jump was necessary.
    if (bool_needsToJump == false) {
        //bool_recalculateMov = false;
    }
}

// Set track information in string
str_info = string(str_trackName) + "#";
str_info += string(int_trackPos) + "sec" + "#";
str_info += "Movement: " + string(map_movement[? "name"]) + "#";
str_info += "Closest endpoint: " + string(int_closestEnd) + "#";
str_info += "Endpoint before loop: " + string(int_movEnd) + "#";
if (os_browser != browser_chrome) {
    str_info += "Please use Chrome, otherwise it doesnt work."
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Set font
draw_set_font(fnt_default);

// State rectangles
draw_set_color(c_black);
draw_rectangle(0,0,300,175,false);
draw_rectangle(600,0,900,175,false);
draw_set_color(c_white);
draw_rectangle(300,0,600,175,false);

// State texts
draw_set_color(c_white);
draw_text_transformed(50,50,"MUTE",2,2,0);
draw_text_transformed(650,50,"TWO",2,2,0);
draw_set_color(c_black);
draw_text_transformed(350,50,"ONE",2,2,0);

// Current state
switch (int_current) {
    case 0:
        draw_set_color(c_white);
        draw_rectangle(50,100,100,150,false);
        break;
    case 1:
        draw_set_color(c_black);
        draw_rectangle(350,100,400,150,false);
        break;
    case 2:
        draw_set_color(c_white);
        draw_rectangle(650,100,700,150,false);
        break;
}

// Track information
draw_set_color(c_black);
draw_text_transformed(50,200,str_info,2,2,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
